# JavaScript Best Practice Guide, Лучшие практики JavaScript.

1. <a href='#first-section'>Избегайте глобальных переменных</a>
2. <a href='#second-section'>Объявления сверху</a>
3. <a href='#third-section'>Инициализируйте переменные при их объявлении.</a>
4. <a href='#eighth-section'>Объявляйте переменные для 'for" вне циклов.</a>
5. <a href='#fourth-section'>Стрелочные функции</a>
6. <a href='#ninth-section'>Функции</a>
7. <a href='#fifth-section'>Не используйте new Object()</a>
8. <a href='#sixth-section'>Уровни вложенности</a>
9. <a href='#seventh-section'>Операторы сравнения</a>
10. <a href='#tenth-section'>Использование шаблонных строк вместо конкатенации</a>

## <a name='first-section'>1. Избегайте глобальных переменных.</a>

Сведите к минимуму использование глобальных переменных. Это включает в себя все типы данных, объекты и функции. Глобальные переменные будут доступны во всем коде JavaScript, поэтому существует вероятность конфликта имен, когда разные части кода будут определять глобальные переменные с одинаковым именем, но используемые для различных целей. Используйте локальные переменные вместо этого.
```
// плохо
let name = 'Jeffrey';  
let lastName = 'Way';  
  
function doSomething() {...}  
  
console.log(name); // Jeffrey -- or window.name 

// хорошо
let DudeNameSpace = {  
   name : 'Jeffrey',  
   lastName : 'Way',  
   doSomething : function() {...}  
}  
console.log(DudeNameSpace.name); // Jeffrey  
```
Мы уменьшили количество глобальных переменных до одного, странным образом названного, обьекта «DudeNameSpace».

## <a name='third-section'>2. Объявления сверху.</a>

Хорошей практикой написания кода является размещение всех объявлений в начале каждого скрипта или функции.
Это:
+ Сделает чище код
+ Предоставит единственное место для поиска локальных переменных
+ Позволит избегать нежелательных (подразумеваемых) глобальных переменных
+ Уменьшит возможность нежелательных повторных объявлений
```
// Объявите в начале
let firstName, lastName, price, discount, fullPrice;

// Используйте после
firstName = "John";
lastName = "Doe";

price = 19.90;
discount = 0.10;

fullPrice = price * 100 / discount; 
```

## <a name='fifth-section'>3. Инициализируйте переменные при их объявлении..</a>

Хорошей практикой кодирования является инициализация переменных при их объявлении.
Это:
+ Сделает код чище
+ Предоставит единственное место для инициализации переменных
+ Позволит избежать неопределенных значений
```
// плохо
let firstName;

firstName = Ivan;

// хорошо
let firstName = "Ivan",
```

## <a name='eighth-section'>4. Объявляйте переменные для 'for" вне циклов.</a>

Когда выполняете долгий цикл «for» не заставляйте делать движок больше работы чем нужно.
```
// плохо
for(let i = 0; i < someArray.length; i++) {  
  let container = document.getElementById('container');  
  container.innerHtml += 'my number: ' + i;  
  console.log(i);  
}  

// хорошо
let container = document.getElementById('container');  

for(let i = 0, len = someArray.length; i < len;  i++) {  
  container.innerHtml += 'my number: ' + i;  
  console.log(i);  
}  
```

## <a name='second-section'>5. Стрелочные функции.</a>

Стрелочные функции придают краткость синтаксису и исправляют многие сложности, с ним связанные. Отдавайте предпочтение стрелочным функциям, а не ключевым словам, особенно для вложенных функций. Обычные объявления функций применяются только в особых случаях. В частности, в методах объектов или в конструкторах. Делается это из-за особенностей ключевого слова this.
```
// плохо
[1, 2, 3].map(function (x) {
  const y = x + 1;
  return x * y;
});

// хорошо
[1, 2, 3].map((x) => {
  const y = x + 1;
  return x * y;
});
```

## <a name='ninth-section'>6. Функции .</a>

Стремитесь написать много маленьких чистых функций и минимизируйте, где происходят мутации.
Меньше мутаций легче поддержка.
```
// плохо
const values = {foo: 1};

function impureFunction(items) {
  const bar = 1;

  items.foo = items.a * bar + 2;

  return items.a;
}

const c = impureFunction(values);
```
```
// хорошо

let values = {foo: 1};

function pureFunction (foo) {
  let bar = 1;

  foo = foo * bar + 2;

  return foo;
}

let c = pureFunction(values.foo)
```

## <a name='sixth-section'>7. Не используйте new Object().</a>

+ Используйте {} вместо new Object()
+ Используйте "" вместо new String()
+ Используйте 0 вместо new Number()
+ Используйте false вместо new Boolean()
+ Используйте [] вместо new Array()
+ Используйте /()/ вместо new RegExp()
+ Используйте function (){} вместо new Function()
```
// пример
let x1 = {};           // new object
let x2 = "";           // new primitive string
let x3 = 0;            // new primitive number
let x4 = false;        // new primitive boolean
let x5 = [];           // new array object
let x6 = /()/;         // new regexp object
let x7 = function(){}; // new function object
```
Всегда обрабатывайте числа, строки или логические значения как примитивные значения. Но не как объекты.
Объявление этих типов как объектов замедляет скорость выполнения и вызывает неприятные побочные эффекты:
```
// плохо
let x = "John";             
let y = new String("John");
(x === y) // является false, потому что x является строкой и y является объектом. 
```
```
// еще хуже:
let x = new String("John");             
let y = new String("John");
(x == y) // является false, потому что вы не можете сравнивать объекты. 
```

## <a name='fourth-section'>8. Уровни вложенности.</a>

+ Уровней вложенности должно быть немного.
+ Лучше быстро обработать простые случаи, вернуть результат, а дальше разбираться со сложным, без дополнительного уровня вложенности.
+ Главное — не краткость кода, а его простота и читаемость. Совсем не всегда более короткий код проще для понимания, чем более развёрнутый.

Например функцию:
```
// плохо
function isEven(n) { // проверка чётности
    if (n % 2 == 0) {
        return true;
    }
    else {
        return false;
    }
}
```
можно упростить избавившись от лишней вложенности:
```
// хорошо
function isEven(n) { // проверка чётности
    if (n % 2 == 0) {
        return true;
    }

    return false;
}
```

## <a name='seventh-section'>9. Операторы сравнения.</a>

Используйте "===" для сравнения, вместо "==". Использование данного оператора позволяет избежать нежелательного преобразования типов данных. Если нам необходимо удостовериться, что переменные действительно идентичны друг другу, стоит использовать строгое равенство.
Оператор == в действительности не сравнивает объекты, а пытается привести их к одному типу. К примеру, в выражении 5 == '5', строка справа конвертируется в число, и только потом сравнивается. Тогда как "===" не делает такого преобразования. Использование сравнения с преобразованием типов может привести к непредвиденным проблемам, связанным с особенностями конвертации разных типов. Например, Объекты String имеют тип Object, а не String. 

```
// пример
0 == "";        // true
1 == "1";       // true
1 == true;      // true

0 === "";       // false
1 === "1";      // false
1 === true;     // false 
```

## <a name='tenth-section'>10. Использование шаблонных строк вместо конкатенации.</a>

Используйте строки шаблона (отделенные с помощью `), а не сложную конкатенацию строк, особенно если задействованы несколько строковых литералов. Строки шаблона могут охватывать несколько строк.
```
// плохо
function sayHi(name) {
  return 'How are you, ' + name + '?';
}

// плохо
function sayHi(name) {
  return ['How are you, ', name, '?'].join();
}

// плохо
function sayHi(name) {
  return `How are you, ${ name }?`;
}

// хорошо
function sayHi(name) {
  return `How are you, ${name}?`;
}
```
